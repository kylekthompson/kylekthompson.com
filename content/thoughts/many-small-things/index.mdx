---
title: Many Small Things
description: >-
  A comparison of big things and small things where we think about dependencies, code composition, and how we can
  re-think our code to be reusable.
date: 2019-04-13
author: Kyle Thompson
bannerImage: ./images/banner.jpg
bannerCredit: _Photo by [Hans-Peter Gauster](https://unsplash.com/photos/3y1zF4hIPCg)_
bannerAlt: Many small puzzle pieces
categories:
  - programming
  - ruby
  - architecture
  - software design
keywords:
  - composition
  - programming
  - ruby
  - architecture
  - software design
published: true
---

import Link from '../../shared/components/external-link';

Recently at work, I've had a lot of time to think about how we architect and design our server in a way that will scale
for our current needs and future ventures. While doing that, I feel like I keep coming back to a few small, guiding
ideas that I'm planning on writing about. To start out the mini-series, let's talk about big things and small things.

Before getting right into it, though, I thought it might be good to give a bit of an overview on why I'm thinking about
it at all.

# Why is this important to me?

At <Link href="https://root.engineering/">Root</Link>, I'm currently an engineer on two teams: Application
Infrastructure (not quite what it sounds like) and New Products/Product Variants.

At first read, that doesn't sound entirely related, but it might make more sense after hearing a bit about what we do on
those teams.

On the Application Infrastructure team, we're responsible for the overall architectural direction of our backend and
client codebases as well as developer productivity and the tools around that. On the New Products/ Product Variants
team, we're responsible for building out new products or varying our existing ones (aptly named, right?) and making sure
we can scale that while growing out both horizontally and vertically.

Insurance is an _extremely_ complex domain to work in so while "building out new products and varying existing ones"
might sound straight-forward, there are a ton of product and state specific domain requirements that we need to build
out and maintain while we expand to every state. Given that background, it kinda makes sense to have a bit of overlap
between those teams since there will naturally be architectural concerns while trying to build out entire new offerings
or new flavors of existing ones.

Like any other complex system, we need to be pretty careful about how we write our code to make sure new engineers can
efficiently onboard and make meaningful contributions without understanding the entire application. Additionally, we
need to make sure that we aren't constraining ourselves so that our longer-tenured employees feel like they're able to
properly build their features.

# The problem

In insurance, we have a lot of moving pieces. At a high level, going from zero to policyholder looks something like
this:

1. Collect account information (email/password)
1. Collect profile information (address, license numbers, VINs, etc.)
1. Use that information to fetch reports from external services
1. Record the test drive
1. Use the profile information, reports, and driving data to figure out what to charge
1. Decide on a set of coverages to get a quote
1. Purchase the policy

There's a lot of insurance-specific stuff in there, but you can probably see a few pieces at least: accounts, profiles,
reports, test drive, rating, quotes, and policies. Even ignoring the rest of our domain, you can see how things might
get unwieldy pretty fast.

An initial attempt at modeling this might look something like this:

```ruby
class Policy < ApplicationRecord
  belongs_to :quote
end

class Quote < ApplicationRecord
  belongs_to :rate
  has_many :coverages
end

class Rate < ApplicationRecord
  belongs_to :profile
  has_many :premiums
  has_many :drivers, through: :profile
  has_many :driving_data, through: :drivers
  has_many :rate_reports
  has_many :reports, through: :rate_reports
end

class DrivingData < ApplicationRecord
  belongs_to :driver
end

class Report < ApplicationRecord
  belongs_to :profile
end

class Profile < ApplicationRecord
  belongs_to :account
  has_many :drivers
end
```

In this example, you can see below that each step in the process knows about the step before. Since it has that
knowledge and a hard dependency on it, we end up with a really tall dependency graph.

```ruby {2,6,11,20,24,28}
class Policy < ApplicationRecord
  belongs_to :quote
end

class Quote < ApplicationRecord
  belongs_to :rate
  has_many :coverages
end

class Rate < ApplicationRecord
  belongs_to :profile
  has_many :premiums
  has_many :drivers, through: :profile
  has_many :driving_data, through: :drivers
  has_many :rate_reports
  has_many :reports, through: :rate_reports
end

class DrivingData < ApplicationRecord
  belongs_to :driver
end

class Report < ApplicationRecord
  belongs_to :profile
end

class Profile < ApplicationRecord
  belongs_to :account
  has_many :drivers
end
```

While we do have some small things at the bottom of the stack (like the profile and account), we also have a
really-big-thing at the very top of the stack.

# Why can't this scale?

In a lot of cases, this might not be a big deal (and we definitely should avoid overcomplicating the code if that is the
case). That being said, in a sufficiently complex domain like ours, you'll probably run into some problems. Off the top
of my head, here are a few:

1. When one unrelated thing at the bottom changes, everything above it can break
1. Setting up tests becomes cumbersome and slow (to create a policy, you'll need everything below it)
1. Pieces at the top of the stack know about _everything_
1. New functionality can (for the most part) only scale vertically by adding to the top of the stack

For the purposes of this post, we'll look mostly at points 1, 3, and 4. Testing will end up being an afterthought of
sorts, but it should naturally become easier with the solution we land on.

At Root, we currently have two variants of car insurance. We'll call them "drive-first" and "drive-later." They are
more-or-less what they sound like. In drive-first, you'll download our app, sign up, take a test drive, get a quote once
that is done, and finally purchase a policy. In drive-later, the test drive step is _after_ you purchase the policy-
you'll start out with a policy and take a thirty-day test drive while already a policyholder. After that, you'll get a
final price based on your driving.

The example modeling that I laid out above can handle drive-first perfectly fine with a little extra code:

```ruby
module PolicyService
  def self.purchase(account:, quote:)
    pay_for(quote: quote)
    Policy.create!(...)
  end
end

module QuoteService
  def self.quote(account:, rate:, selections:)
    verify_coverage_selections(selections: selections)
    generate_quote_for(
      rate: rate,
      selections: selections
    )
  end
end

module RateService
  def self.rate(account:, profile:)
    reports = Reports.where(account: account)
    driving_data = DrivingData.where(account: account)

    rating_data = rating_data(
      profile: profile,
      reports: reports,
      driving_data: driving_data
    )
    premiums = calculate_premiums(rating_data: rating_data)

    create_rate(
      profile: profile,
      reports: reports,
      driving_data: driving_data,
      premiums: premiums
    )
  end
end

# etc.
```

Let's think a little about the differences between drive-first and drive-later, though:

- The **test drive** happens before the rate is created in drive-first but after the policy is purchased in drive-later
- 30 days after purchasing the policy in drive-later, the customer is **rerated** with the new driving data
- 60 days after purchasing the policy in drive-later, the policy is either **canceled or updated** to use the new rate
  with driving data

The last two differences are both additive, and the first is a change. As mentioned earlier, a tall dependency stack
makes it difficult and potentially risky to make a change to a part of the stack. Because of that (and that additions
are generally easier to implement), we'll focus the rest of this post on the first difference.

# How do we avoid the risk?

In an ideal system, we should be able to easily support change whether it's changing existing functionality or adding
new functionality (you can still think of this as a change to the system overall). To do that without fear of everything
toppling over, we can re-think the structure of our code. Rather than building a big and tall stack of code, we should
try to build a lot of small pieces that we can compose together in a short stack.

## Small things

Consider the previous process of purchasing a policy. I initially described it as a single process- from being some
anonymous person all the way to being a policyholder. Is that actually the case, though?

Earlier, we broke out some core ideas from the become-a-policyholder process: profiles, reports, test drive, rates,
quotes, and policies. When we initially talked about it, each thing built on top of each other.

But what if they didn't? What if they were distinct, separate small pieces of functionality? The profiles piece might
know how to store the profile information and provide that to anything that might need it. The reports piece might know
how to run external reports and persist them. And so on for the other pieces.

On their own, though, these smaller pieces are all pretty meaningless from a business perspective. You could almost go
as far as thinking of them as third-party services or libraries if you wanted to.

## Composition and orchestration

By itself, the "many small things" idea doesn't _quite_ work, since there isn't a great way to define a whole business
process as many small things (it's a little contradictory if you think about it).

At some point, we'll need to take these small things, put some business logic around them, and define a more
medium-sized thing that provides some business value. You could imagine having multiple thin orchestration layers on top
of those small pieces.

In the earlier become-a-policyholder process, all of the logic was in one place and joined together. In a world of many
small things with thin orchestration layers on top, we might have a few distinct layers that all live independently of
one another: sign up, collect driving data, get a quote, and purchase a policy.

Each of these pieces might rely on some parts within the other, but the important part to note is that they don't rely
on everything. This distinction saves us from a number of the pitfalls I mentioned earlier.

Because we've already broken up a lot of our functionality into smaller pieces, these medium-sized business processes
that better define the stages of the business can now compose those smaller pieces into something that provides value.
And even better, if we want a new product variant it's as simple as composing those pieces in a different way.

# What does this look like in practice?

Let's go back to the drive-first and drive-later product variants that we need to support and think through
re-designing the models and services that we have so far to open them up to change. We'll walk through making
adjustments to the models and service layer to support purchasing a policy without taking a test drive in a
many-small-things way.

## A quick re-model

Let's step back and look at our existing modeling of this process to refresh our memory:

```ruby
class Policy < ApplicationRecord
  belongs_to :quote
end

class Quote < ApplicationRecord
  belongs_to :rate
  has_many :coverages
end

class Rate < ApplicationRecord
  belongs_to :profile
  has_many :premiums
  has_many :drivers, through: :profile
  has_many :driving_data, through: :drivers
  has_many :rate_reports
  has_many :reports, through: :rate_reports
end

class DrivingData < ApplicationRecord
  belongs_to :driver
end

class Report < ApplicationRecord
  belongs_to :profile
end

class Profile < ApplicationRecord
  belongs_to :account
  has_many :drivers
end
```

### Removing dependencies

To break up this tall stack, we'll start by breaking some dependencies (I'll comment them out for clarity):

```ruby {6,11,13-16}
class Policy < ApplicationRecord
  belongs_to :quote
end

class Quote < ApplicationRecord
  # belongs_to :rate
  has_many :coverages
end

class Rate < ApplicationRecord
  # belongs_to :profile
  has_many :premiums
  # has_many :drivers, through: :profile
  # has_many :driving_data, through: :drivers
  # has_many :rate_reports
  # has_many :reports, through: :rate_reports
end

class DrivingData < ApplicationRecord
  belongs_to :driver
end

class Report < ApplicationRecord
  belongs_to :profile
end

class Profile < ApplicationRecord
  belongs_to :account
  has_many :drivers
end
```

You can see that I've removed the `belongs_to :rate` from the quote and the `belongs_to :profile` from the rate (as well
as a few other `has_many` relations). Let's talk about the _why_ of that, though.

Previously, the `Quote` and `Rate` had references to anything _that contributed to their creation_, but the thing is-
none of those records are really needed to create a quote or rate. A `Quote` is simply a subset of the premiums from the
rate. The rate is really only attached so we can for-sure say "this is how the quote was generated." Similarly, a `Rate`
is simply a set of premiums that we've calculated for some set of information (in this case, driving data, reports, and
the profile), and it only had references to the profile and other relations for auditability.

If that's truly the case, then why not model the auditing separately?

```ruby {9-12,18-25}
class AuditQuote < ApplicationRecord
  belongs_to :quote
  belongs_to :rate
end

class AuditRate < ApplicationRecord
  belongs_to :rate
  belongs_to :profile
  has_many :drivers, through: :profile
  has_many :driving_data, through: :drivers
  has_many :rate_reports
  has_many :reports, through: :rate_reports
end
```

With this addition of a new `AuditRate` and `AuditQuote` (don't mind the naming ðŸ˜…), we have a nice separation of
concerns and we've broken down the tall dependency graph into something shorter. With that, we have some nice benefits:

- We've set ourselves up to _generate rates and quotes in different ways_
- To create a policy, all we need is a quote with some premiums (so testing setup is a lot easier)
- Policy creation isn't dependent at all on how a rate is created, so bottom-of-the-stack changes won't ripple up

### Modeling product variants

To properly support drive-first and drive-later, various aspects of our system will need to know about what "variant" a
certain account is in. To handle that, we can introduce a new concept:

```ruby
class ProductVariant < ApplicationRecord
  belongs_to :account
end
```

This model is pretty small, but also pretty powerful. By pushing this low in the stack, the various orchestration layers
we talked about earlier can say "Hey, what kind of variant am I working with here? We'll want to create rating data for
that one." without depending on _everything_ in the system.

## Re-thinking our services

So we talked about the three main differences between drive-first and drive-later. The first one was about when the test
drive happened. For the most part, we're ready to support the change to when that happens. Recall our `RateService` from
earlier:

```ruby
module RateService
  def self.rate(account:, profile:)
    reports = Reports.where(account: account)
    driving_data = DrivingData.where(account: account)

    rating_data = rating_data(
      profile: profile,
      reports: reports,
      driving_data: driving_data
    )
    premiums = calculate_premiums(rating_data: rating_data)

    create_rate(
      profile: profile,
      reports: reports,
      driving_data: driving_data,
      premiums: premiums
    )
  end
end
```

Before making any changes, let's talk through the process of creating a rate:

1. Fetch some domain data
1. Use that data to build _rating_ data
1. Use that rating data to calculate premiums
1. Persist those premiums (and what we used to calculate them) as a "rate"

This service already acts more-or-less like an orchestration layer when broken down into steps like this, but the main
issue is that it's only orchestrating itself. Because of that, all of the logic lives within this one really big
service, so it isn't really open for change.

The main things that are "locking it down" from my perspective are:

- The hard dependency on using the driving data to build rating data
- Rate creation requires a profile, reports, and driving data

```ruby {3-4,6-10}
module RateService
  def self.rate(account:, profile:)
    reports = Reports.where(account: account)
    driving_data = DrivingData.where(account: account)

    rating_data = rating_data(
      profile: profile,
      reports: reports,
      driving_data: driving_data
    )
    premiums = calculate_premiums(rating_data: rating_data)

    create_rate(
      profile: profile,
      reports: reports,
      driving_data: driving_data,
      premiums: premiums
    )
  end
end
```

With that in mind, let's try to break out a few smaller things from this big service:

```ruby
module RatePremiumService
  def self.calculate_premiums(rating_data:)
    # super-secret premium calculation code here
  end
end

module DriveFirstRatingDataService
  def self.build(account:, profile:)
    reports = Reports.where(account: account)
    driving_data = DrivingData.where(account: account)

    # super-secret rating data creation process
    # with the profile, reports, and driving data
  end
end

module RateService
  def self.rate!(product_variant:, account:, profile:)
    rating_data = rating_data_service_for(variant: product_variant).build(
      account: account,
      profile: profile
    )
    premiums = RatePremiumService.calculate_premiums(rating_data: rating_data)
    Rate.create!(account: account, premiums: premiums)
  end
end
```

So, what has changed?

- We are taking a new dependency on the `ProductVariant` that we modeled earlier
- We split out the `build_rating_data` method to a new service responsible only for that
- From that product variant, we can choose the correct rating data service
- `RateService` now only composes other smaller pieces

At the end of the day, `RateService` looks pretty similar. It encapsulates and orchestrates the process of creating a
rate, but it does so while allowing the previously defined business rules to change based on the product variant. All of
the "steps" to create a rate end up well-defined, so when we want to test out a new product variant, it's
straightforward to do what we need- define a new rating data service that can build rating data for that specific
variant.

## Supporting drive-later

Now that we've done the up front work to break down our really-big-thing into many-small-things, let's put that to work
by adding support for our drive-later product variant. Previously, we had definded a single
`DriveFirstRatingDataService` to keep the functionality on-par with the old `RateService`, but let's go ahead and extend
that to drive-later now:

```ruby
module DriveLaterRatingDataService
  def self.build(account:, profile:)
    reports = Reports.where(account: account)

    # super-secret rating data creation process
    # with the profile and reports
  end
end
```

You'll note here that we now have two rating data services to go along with our two product variants. The `RateService`
is still in charge of creating rates, but we've opened it up for extension by providing a way to build rating data in
whatever way a product variant requires.

Since we have rating data set up in this way, you could imagine what creating new product variants might look like in
the future. For example, consider a product variant where we priced a customer based on how often their puppy barked:

```ruby
module PuppyBarkRatingDataService
  def self.build(account:, profile:)
    reports = Report.where(account: account)
    barks = Bark.from_puppies.where(profile: profile)

    # super-secret rating data creation process
    # with the profile, reports, and barks
  end
end
```
